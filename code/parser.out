Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    COMMENTM

Grammar

Rule 0     S' -> prog
Rule 1     prog -> block
Rule 2     block -> declarations program_body
Rule 3     declarations -> declaration SEMICOLON declarations
Rule 4     declarations -> <empty>
Rule 5     declaration -> var_declaration
Rule 6     declaration -> fun_declaration
Rule 7     var_declaration -> VAR basic_var_declaration
Rule 8     basic_var_declaration -> identifier COLON type
Rule 9     fun_declaration -> FUN identifier param_list COLON type CLPAR fun_block CRPAR
Rule 10    fun_block -> declarations fun_body
Rule 11    param_list -> LPAR parameters RPAR
Rule 12    parameters -> parameters1
Rule 13    parameters -> <empty>
Rule 14    parameters1 -> parameters1 COMMA basic_var_declaration
Rule 15    parameters1 -> basic_var_declaration
Rule 16    identifier -> ID
Rule 17    type -> INT
Rule 18    type -> BOOL
Rule 19    program_body -> BEGIN prog_stmts END
Rule 20    fun_body -> BEGIN prog_stmts RETURN expr SEMICOLON END
Rule 21    fun_body -> prog_stmts RETURN expr SEMICOLON
Rule 22    prog_stmts -> prog_stmt SEMICOLON prog_stmts
Rule 23    prog_stmts -> <empty>
Rule 24    prog_stmt -> IF expr THEN prog_stmt ELSE prog_stmt
Rule 25    prog_stmt -> WHILE expr DO prog_stmt
Rule 26    prog_stmt -> READ ID
Rule 27    prog_stmt -> ID ASSIGN expr
Rule 28    prog_stmt -> PRINT expr
Rule 29    prog_stmt -> CLPAR block CRPAR
Rule 30    expr -> expr OR bint_term
Rule 31    expr -> bint_term
Rule 32    bint_term -> bint_term AND bint_factor
Rule 33    bint_term -> bint_factor
Rule 34    bint_factor -> NOT bint_factor
Rule 35    bint_factor -> int_expr compare_op int_expr
Rule 36    bint_factor -> int_expr
Rule 37    compare_op -> EQUAL
Rule 38    compare_op -> LT
Rule 39    compare_op -> GT
Rule 40    compare_op -> LE
Rule 41    compare_op -> GE
Rule 42    int_expr -> int_expr addop int_term
Rule 43    int_expr -> int_term
Rule 44    addop -> ADD
Rule 45    addop -> SUB
Rule 46    int_term -> int_term mulop int_factor
Rule 47    int_term -> int_factor
Rule 48    mulop -> MUL
Rule 49    mulop -> DIV
Rule 50    int_factor -> LPAR expr RPAR
Rule 51    int_factor -> ID argument_list
Rule 52    int_factor -> NUM
Rule 53    int_factor -> BVAL
Rule 54    int_factor -> SUB int_factor
Rule 55    argument_list -> LPAR arguments RPAR
Rule 56    argument_list -> <empty>
Rule 57    arguments -> arguments1
Rule 58    arguments -> <empty>
Rule 59    arguments1 -> arguments1 COMMA expr
Rule 60    arguments1 -> expr

Terminals, with rules where they appear

ADD                  : 44
AND                  : 32
ASSIGN               : 27
BEGIN                : 19 20
BOOL                 : 18
BVAL                 : 53
CLPAR                : 9 29
COLON                : 8 9
COMMA                : 14 59
COMMENT              : 
COMMENTM             : 
CRPAR                : 9 29
DIV                  : 49
DO                   : 25
ELSE                 : 24
END                  : 19 20
EQUAL                : 37
FUN                  : 9
GE                   : 41
GT                   : 39
ID                   : 16 26 27 51
IF                   : 24
INT                  : 17
LE                   : 40
LPAR                 : 11 50 55
LT                   : 38
MUL                  : 48
NOT                  : 34
NUM                  : 52
OR                   : 30
PRINT                : 28
READ                 : 26
RETURN               : 20 21
RPAR                 : 11 50 55
SEMICOLON            : 3 20 21 22
SUB                  : 45 54
THEN                 : 24
VAR                  : 7
WHILE                : 25
error                : 

Nonterminals, with rules where they appear

addop                : 42
argument_list        : 51
arguments            : 55
arguments1           : 57 59
basic_var_declaration : 7 14 15
bint_factor          : 32 33 34
bint_term            : 30 31 32
block                : 1 29
compare_op           : 35
declaration          : 3
declarations         : 2 3 10
expr                 : 20 21 24 25 27 28 30 50 59 60
fun_block            : 9
fun_body             : 10
fun_declaration      : 6
identifier           : 8 9
int_expr             : 35 35 36 42
int_factor           : 46 47 54
int_term             : 42 43 46
mulop                : 46
param_list           : 9
parameters           : 11
parameters1          : 12 14
prog                 : 0
prog_stmt            : 22 24 24 25
prog_stmts           : 19 20 21 22
program_body         : 2
type                 : 8 9
var_declaration      : 5

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . block
    (2) block -> . declarations program_body
    (3) declarations -> . declaration SEMICOLON declarations
    (4) declarations -> .
    (5) declaration -> . var_declaration
    (6) declaration -> . fun_declaration
    (7) var_declaration -> . VAR basic_var_declaration
    (9) fun_declaration -> . FUN identifier param_list COLON type CLPAR fun_block CRPAR

    BEGIN           reduce using rule 4 (declarations -> .)
    VAR             shift and go to state 8
    FUN             shift and go to state 2

    prog                           shift and go to state 1
    fun_declaration                shift and go to state 3
    block                          shift and go to state 4
    declarations                   shift and go to state 6
    var_declaration                shift and go to state 7
    declaration                    shift and go to state 5

state 1

    (0) S' -> prog .



state 2

    (9) fun_declaration -> FUN . identifier param_list COLON type CLPAR fun_block CRPAR
    (16) identifier -> . ID

    ID              shift and go to state 9

    identifier                     shift and go to state 10

state 3

    (6) declaration -> fun_declaration .

    SEMICOLON       reduce using rule 6 (declaration -> fun_declaration .)


state 4

    (1) prog -> block .

    $end            reduce using rule 1 (prog -> block .)


state 5

    (3) declarations -> declaration . SEMICOLON declarations

    SEMICOLON       shift and go to state 11


state 6

    (2) block -> declarations . program_body
    (19) program_body -> . BEGIN prog_stmts END

    BEGIN           shift and go to state 12

    program_body                   shift and go to state 13

state 7

    (5) declaration -> var_declaration .

    SEMICOLON       reduce using rule 5 (declaration -> var_declaration .)


state 8

    (7) var_declaration -> VAR . basic_var_declaration
    (8) basic_var_declaration -> . identifier COLON type
    (16) identifier -> . ID

    ID              shift and go to state 9

    basic_var_declaration          shift and go to state 15
    identifier                     shift and go to state 14

state 9

    (16) identifier -> ID .

    LPAR            reduce using rule 16 (identifier -> ID .)
    COLON           reduce using rule 16 (identifier -> ID .)


state 10

    (9) fun_declaration -> FUN identifier . param_list COLON type CLPAR fun_block CRPAR
    (11) param_list -> . LPAR parameters RPAR

    LPAR            shift and go to state 16

    param_list                     shift and go to state 17

state 11

    (3) declarations -> declaration SEMICOLON . declarations
    (3) declarations -> . declaration SEMICOLON declarations
    (4) declarations -> .
    (5) declaration -> . var_declaration
    (6) declaration -> . fun_declaration
    (7) var_declaration -> . VAR basic_var_declaration
    (9) fun_declaration -> . FUN identifier param_list COLON type CLPAR fun_block CRPAR

    BEGIN           reduce using rule 4 (declarations -> .)
    IF              reduce using rule 4 (declarations -> .)
    WHILE           reduce using rule 4 (declarations -> .)
    READ            reduce using rule 4 (declarations -> .)
    ID              reduce using rule 4 (declarations -> .)
    PRINT           reduce using rule 4 (declarations -> .)
    CLPAR           reduce using rule 4 (declarations -> .)
    RETURN          reduce using rule 4 (declarations -> .)
    VAR             shift and go to state 8
    FUN             shift and go to state 2

    declarations                   shift and go to state 18
    fun_declaration                shift and go to state 3
    var_declaration                shift and go to state 7
    declaration                    shift and go to state 5

state 12

    (19) program_body -> BEGIN . prog_stmts END
    (22) prog_stmts -> . prog_stmt SEMICOLON prog_stmts
    (23) prog_stmts -> .
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    END             reduce using rule 23 (prog_stmts -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 24
    PRINT           shift and go to state 21
    CLPAR           shift and go to state 26

    prog_stmt                      shift and go to state 19
    prog_stmts                     shift and go to state 20

state 13

    (2) block -> declarations program_body .

    CRPAR           reduce using rule 2 (block -> declarations program_body .)
    $end            reduce using rule 2 (block -> declarations program_body .)


state 14

    (8) basic_var_declaration -> identifier . COLON type

    COLON           shift and go to state 27


state 15

    (7) var_declaration -> VAR basic_var_declaration .

    SEMICOLON       reduce using rule 7 (var_declaration -> VAR basic_var_declaration .)


state 16

    (11) param_list -> LPAR . parameters RPAR
    (12) parameters -> . parameters1
    (13) parameters -> .
    (14) parameters1 -> . parameters1 COMMA basic_var_declaration
    (15) parameters1 -> . basic_var_declaration
    (8) basic_var_declaration -> . identifier COLON type
    (16) identifier -> . ID

    RPAR            reduce using rule 13 (parameters -> .)
    ID              shift and go to state 9

    parameters1                    shift and go to state 29
    basic_var_declaration          shift and go to state 30
    parameters                     shift and go to state 28
    identifier                     shift and go to state 14

state 17

    (9) fun_declaration -> FUN identifier param_list . COLON type CLPAR fun_block CRPAR

    COLON           shift and go to state 31


state 18

    (3) declarations -> declaration SEMICOLON declarations .

    BEGIN           reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    IF              reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    WHILE           reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    READ            reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    ID              reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    PRINT           reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    CLPAR           reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    RETURN          reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)


state 19

    (22) prog_stmts -> prog_stmt . SEMICOLON prog_stmts

    SEMICOLON       shift and go to state 32


state 20

    (19) program_body -> BEGIN prog_stmts . END

    END             shift and go to state 33


state 21

    (28) prog_stmt -> PRINT . expr
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_term                       shift and go to state 34
    int_expr                       shift and go to state 36
    expr                           shift and go to state 37
    int_factor                     shift and go to state 40
    bint_factor                    shift and go to state 43
    bint_term                      shift and go to state 45

state 22

    (25) prog_stmt -> WHILE . expr DO prog_stmt
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_expr                       shift and go to state 36
    expr                           shift and go to state 46
    int_factor                     shift and go to state 40
    int_term                       shift and go to state 34
    bint_factor                    shift and go to state 43
    bint_term                      shift and go to state 45

state 23

    (26) prog_stmt -> READ . ID

    ID              shift and go to state 47


state 24

    (27) prog_stmt -> ID . ASSIGN expr

    ASSIGN          shift and go to state 48


state 25

    (24) prog_stmt -> IF . expr THEN prog_stmt ELSE prog_stmt
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_expr                       shift and go to state 36
    expr                           shift and go to state 49
    int_factor                     shift and go to state 40
    int_term                       shift and go to state 34
    bint_factor                    shift and go to state 43
    bint_term                      shift and go to state 45

state 26

    (29) prog_stmt -> CLPAR . block CRPAR
    (2) block -> . declarations program_body
    (3) declarations -> . declaration SEMICOLON declarations
    (4) declarations -> .
    (5) declaration -> . var_declaration
    (6) declaration -> . fun_declaration
    (7) var_declaration -> . VAR basic_var_declaration
    (9) fun_declaration -> . FUN identifier param_list COLON type CLPAR fun_block CRPAR

    BEGIN           reduce using rule 4 (declarations -> .)
    VAR             shift and go to state 8
    FUN             shift and go to state 2

    block                          shift and go to state 50
    declarations                   shift and go to state 6
    fun_declaration                shift and go to state 3
    var_declaration                shift and go to state 7
    declaration                    shift and go to state 5

state 27

    (8) basic_var_declaration -> identifier COLON . type
    (17) type -> . INT
    (18) type -> . BOOL

    INT             shift and go to state 52
    BOOL            shift and go to state 53

    type                           shift and go to state 51

state 28

    (11) param_list -> LPAR parameters . RPAR

    RPAR            shift and go to state 54


state 29

    (12) parameters -> parameters1 .
    (14) parameters1 -> parameters1 . COMMA basic_var_declaration

    RPAR            reduce using rule 12 (parameters -> parameters1 .)
    COMMA           shift and go to state 55


state 30

    (15) parameters1 -> basic_var_declaration .

    COMMA           reduce using rule 15 (parameters1 -> basic_var_declaration .)
    RPAR            reduce using rule 15 (parameters1 -> basic_var_declaration .)


state 31

    (9) fun_declaration -> FUN identifier param_list COLON . type CLPAR fun_block CRPAR
    (17) type -> . INT
    (18) type -> . BOOL

    INT             shift and go to state 52
    BOOL            shift and go to state 53

    type                           shift and go to state 56

state 32

    (22) prog_stmts -> prog_stmt SEMICOLON . prog_stmts
    (22) prog_stmts -> . prog_stmt SEMICOLON prog_stmts
    (23) prog_stmts -> .
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    END             reduce using rule 23 (prog_stmts -> .)
    RETURN          reduce using rule 23 (prog_stmts -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 24
    PRINT           shift and go to state 21
    CLPAR           shift and go to state 26

    prog_stmt                      shift and go to state 19
    prog_stmts                     shift and go to state 57

state 33

    (19) program_body -> BEGIN prog_stmts END .

    $end            reduce using rule 19 (program_body -> BEGIN prog_stmts END .)
    CRPAR           reduce using rule 19 (program_body -> BEGIN prog_stmts END .)


state 34

    (43) int_expr -> int_term .
    (46) int_term -> int_term . mulop int_factor
    (48) mulop -> . MUL
    (49) mulop -> . DIV

    EQUAL           reduce using rule 43 (int_expr -> int_term .)
    LT              reduce using rule 43 (int_expr -> int_term .)
    GT              reduce using rule 43 (int_expr -> int_term .)
    LE              reduce using rule 43 (int_expr -> int_term .)
    GE              reduce using rule 43 (int_expr -> int_term .)
    ADD             reduce using rule 43 (int_expr -> int_term .)
    SUB             reduce using rule 43 (int_expr -> int_term .)
    AND             reduce using rule 43 (int_expr -> int_term .)
    SEMICOLON       reduce using rule 43 (int_expr -> int_term .)
    OR              reduce using rule 43 (int_expr -> int_term .)
    ELSE            reduce using rule 43 (int_expr -> int_term .)
    DO              reduce using rule 43 (int_expr -> int_term .)
    THEN            reduce using rule 43 (int_expr -> int_term .)
    RPAR            reduce using rule 43 (int_expr -> int_term .)
    COMMA           reduce using rule 43 (int_expr -> int_term .)
    MUL             shift and go to state 60
    DIV             shift and go to state 59

    mulop                          shift and go to state 58

state 35

    (53) int_factor -> BVAL .

    MUL             reduce using rule 53 (int_factor -> BVAL .)
    DIV             reduce using rule 53 (int_factor -> BVAL .)
    EQUAL           reduce using rule 53 (int_factor -> BVAL .)
    LT              reduce using rule 53 (int_factor -> BVAL .)
    GT              reduce using rule 53 (int_factor -> BVAL .)
    LE              reduce using rule 53 (int_factor -> BVAL .)
    GE              reduce using rule 53 (int_factor -> BVAL .)
    ADD             reduce using rule 53 (int_factor -> BVAL .)
    SUB             reduce using rule 53 (int_factor -> BVAL .)
    AND             reduce using rule 53 (int_factor -> BVAL .)
    OR              reduce using rule 53 (int_factor -> BVAL .)
    SEMICOLON       reduce using rule 53 (int_factor -> BVAL .)
    ELSE            reduce using rule 53 (int_factor -> BVAL .)
    DO              reduce using rule 53 (int_factor -> BVAL .)
    THEN            reduce using rule 53 (int_factor -> BVAL .)
    RPAR            reduce using rule 53 (int_factor -> BVAL .)
    COMMA           reduce using rule 53 (int_factor -> BVAL .)


state 36

    (35) bint_factor -> int_expr . compare_op int_expr
    (36) bint_factor -> int_expr .
    (42) int_expr -> int_expr . addop int_term
    (37) compare_op -> . EQUAL
    (38) compare_op -> . LT
    (39) compare_op -> . GT
    (40) compare_op -> . LE
    (41) compare_op -> . GE
    (44) addop -> . ADD
    (45) addop -> . SUB

    AND             reduce using rule 36 (bint_factor -> int_expr .)
    OR              reduce using rule 36 (bint_factor -> int_expr .)
    SEMICOLON       reduce using rule 36 (bint_factor -> int_expr .)
    ELSE            reduce using rule 36 (bint_factor -> int_expr .)
    DO              reduce using rule 36 (bint_factor -> int_expr .)
    THEN            reduce using rule 36 (bint_factor -> int_expr .)
    RPAR            reduce using rule 36 (bint_factor -> int_expr .)
    COMMA           reduce using rule 36 (bint_factor -> int_expr .)
    EQUAL           shift and go to state 62
    LT              shift and go to state 67
    GT              shift and go to state 69
    LE              shift and go to state 63
    GE              shift and go to state 64
    ADD             shift and go to state 66
    SUB             shift and go to state 68

    addop                          shift and go to state 61
    compare_op                     shift and go to state 65

state 37

    (28) prog_stmt -> PRINT expr .
    (30) expr -> expr . OR bint_term

    SEMICOLON       reduce using rule 28 (prog_stmt -> PRINT expr .)
    ELSE            reduce using rule 28 (prog_stmt -> PRINT expr .)
    OR              shift and go to state 70


state 38

    (34) bint_factor -> NOT . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_term                       shift and go to state 34
    int_expr                       shift and go to state 36
    int_factor                     shift and go to state 40
    bint_factor                    shift and go to state 71

state 39

    (52) int_factor -> NUM .

    MUL             reduce using rule 52 (int_factor -> NUM .)
    DIV             reduce using rule 52 (int_factor -> NUM .)
    EQUAL           reduce using rule 52 (int_factor -> NUM .)
    LT              reduce using rule 52 (int_factor -> NUM .)
    GT              reduce using rule 52 (int_factor -> NUM .)
    LE              reduce using rule 52 (int_factor -> NUM .)
    GE              reduce using rule 52 (int_factor -> NUM .)
    ADD             reduce using rule 52 (int_factor -> NUM .)
    SUB             reduce using rule 52 (int_factor -> NUM .)
    AND             reduce using rule 52 (int_factor -> NUM .)
    OR              reduce using rule 52 (int_factor -> NUM .)
    SEMICOLON       reduce using rule 52 (int_factor -> NUM .)
    ELSE            reduce using rule 52 (int_factor -> NUM .)
    DO              reduce using rule 52 (int_factor -> NUM .)
    THEN            reduce using rule 52 (int_factor -> NUM .)
    RPAR            reduce using rule 52 (int_factor -> NUM .)
    COMMA           reduce using rule 52 (int_factor -> NUM .)


state 40

    (47) int_term -> int_factor .

    MUL             reduce using rule 47 (int_term -> int_factor .)
    DIV             reduce using rule 47 (int_term -> int_factor .)
    EQUAL           reduce using rule 47 (int_term -> int_factor .)
    LT              reduce using rule 47 (int_term -> int_factor .)
    GT              reduce using rule 47 (int_term -> int_factor .)
    LE              reduce using rule 47 (int_term -> int_factor .)
    GE              reduce using rule 47 (int_term -> int_factor .)
    ADD             reduce using rule 47 (int_term -> int_factor .)
    SUB             reduce using rule 47 (int_term -> int_factor .)
    AND             reduce using rule 47 (int_term -> int_factor .)
    OR              reduce using rule 47 (int_term -> int_factor .)
    COMMA           reduce using rule 47 (int_term -> int_factor .)
    RPAR            reduce using rule 47 (int_term -> int_factor .)
    DO              reduce using rule 47 (int_term -> int_factor .)
    SEMICOLON       reduce using rule 47 (int_term -> int_factor .)
    ELSE            reduce using rule 47 (int_term -> int_factor .)
    THEN            reduce using rule 47 (int_term -> int_factor .)


state 41

    (51) int_factor -> ID . argument_list
    (55) argument_list -> . LPAR arguments RPAR
    (56) argument_list -> .

    LPAR            shift and go to state 72
    MUL             reduce using rule 56 (argument_list -> .)
    DIV             reduce using rule 56 (argument_list -> .)
    EQUAL           reduce using rule 56 (argument_list -> .)
    LT              reduce using rule 56 (argument_list -> .)
    GT              reduce using rule 56 (argument_list -> .)
    LE              reduce using rule 56 (argument_list -> .)
    GE              reduce using rule 56 (argument_list -> .)
    ADD             reduce using rule 56 (argument_list -> .)
    SUB             reduce using rule 56 (argument_list -> .)
    AND             reduce using rule 56 (argument_list -> .)
    OR              reduce using rule 56 (argument_list -> .)
    SEMICOLON       reduce using rule 56 (argument_list -> .)
    ELSE            reduce using rule 56 (argument_list -> .)
    DO              reduce using rule 56 (argument_list -> .)
    THEN            reduce using rule 56 (argument_list -> .)
    RPAR            reduce using rule 56 (argument_list -> .)
    COMMA           reduce using rule 56 (argument_list -> .)

    argument_list                  shift and go to state 73

state 42

    (50) int_factor -> LPAR . expr RPAR
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_term                       shift and go to state 34
    int_expr                       shift and go to state 36
    expr                           shift and go to state 74
    int_factor                     shift and go to state 40
    bint_factor                    shift and go to state 43
    bint_term                      shift and go to state 45

state 43

    (33) bint_term -> bint_factor .

    AND             reduce using rule 33 (bint_term -> bint_factor .)
    OR              reduce using rule 33 (bint_term -> bint_factor .)
    SEMICOLON       reduce using rule 33 (bint_term -> bint_factor .)
    ELSE            reduce using rule 33 (bint_term -> bint_factor .)
    COMMA           reduce using rule 33 (bint_term -> bint_factor .)
    RPAR            reduce using rule 33 (bint_term -> bint_factor .)
    DO              reduce using rule 33 (bint_term -> bint_factor .)
    THEN            reduce using rule 33 (bint_term -> bint_factor .)


state 44

    (54) int_factor -> SUB . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_factor                     shift and go to state 75

state 45

    (31) expr -> bint_term .
    (32) bint_term -> bint_term . AND bint_factor

    RPAR            reduce using rule 31 (expr -> bint_term .)
    OR              reduce using rule 31 (expr -> bint_term .)
    THEN            reduce using rule 31 (expr -> bint_term .)
    SEMICOLON       reduce using rule 31 (expr -> bint_term .)
    ELSE            reduce using rule 31 (expr -> bint_term .)
    COMMA           reduce using rule 31 (expr -> bint_term .)
    DO              reduce using rule 31 (expr -> bint_term .)
    AND             shift and go to state 76


state 46

    (25) prog_stmt -> WHILE expr . DO prog_stmt
    (30) expr -> expr . OR bint_term

    DO              shift and go to state 77
    OR              shift and go to state 70


state 47

    (26) prog_stmt -> READ ID .

    SEMICOLON       reduce using rule 26 (prog_stmt -> READ ID .)
    ELSE            reduce using rule 26 (prog_stmt -> READ ID .)


state 48

    (27) prog_stmt -> ID ASSIGN . expr
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_term                       shift and go to state 34
    int_expr                       shift and go to state 36
    expr                           shift and go to state 78
    int_factor                     shift and go to state 40
    bint_factor                    shift and go to state 43
    bint_term                      shift and go to state 45

state 49

    (24) prog_stmt -> IF expr . THEN prog_stmt ELSE prog_stmt
    (30) expr -> expr . OR bint_term

    THEN            shift and go to state 79
    OR              shift and go to state 70


state 50

    (29) prog_stmt -> CLPAR block . CRPAR

    CRPAR           shift and go to state 80


state 51

    (8) basic_var_declaration -> identifier COLON type .

    COMMA           reduce using rule 8 (basic_var_declaration -> identifier COLON type .)
    RPAR            reduce using rule 8 (basic_var_declaration -> identifier COLON type .)
    SEMICOLON       reduce using rule 8 (basic_var_declaration -> identifier COLON type .)


state 52

    (17) type -> INT .

    SEMICOLON       reduce using rule 17 (type -> INT .)
    COMMA           reduce using rule 17 (type -> INT .)
    RPAR            reduce using rule 17 (type -> INT .)
    CLPAR           reduce using rule 17 (type -> INT .)


state 53

    (18) type -> BOOL .

    SEMICOLON       reduce using rule 18 (type -> BOOL .)
    COMMA           reduce using rule 18 (type -> BOOL .)
    RPAR            reduce using rule 18 (type -> BOOL .)
    CLPAR           reduce using rule 18 (type -> BOOL .)


state 54

    (11) param_list -> LPAR parameters RPAR .

    COLON           reduce using rule 11 (param_list -> LPAR parameters RPAR .)


state 55

    (14) parameters1 -> parameters1 COMMA . basic_var_declaration
    (8) basic_var_declaration -> . identifier COLON type
    (16) identifier -> . ID

    ID              shift and go to state 9

    basic_var_declaration          shift and go to state 81
    identifier                     shift and go to state 14

state 56

    (9) fun_declaration -> FUN identifier param_list COLON type . CLPAR fun_block CRPAR

    CLPAR           shift and go to state 82


state 57

    (22) prog_stmts -> prog_stmt SEMICOLON prog_stmts .

    END             reduce using rule 22 (prog_stmts -> prog_stmt SEMICOLON prog_stmts .)
    RETURN          reduce using rule 22 (prog_stmts -> prog_stmt SEMICOLON prog_stmts .)


state 58

    (46) int_term -> int_term mulop . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_factor                     shift and go to state 83

state 59

    (49) mulop -> DIV .

    LPAR            reduce using rule 49 (mulop -> DIV .)
    ID              reduce using rule 49 (mulop -> DIV .)
    NUM             reduce using rule 49 (mulop -> DIV .)
    BVAL            reduce using rule 49 (mulop -> DIV .)
    SUB             reduce using rule 49 (mulop -> DIV .)


state 60

    (48) mulop -> MUL .

    LPAR            reduce using rule 48 (mulop -> MUL .)
    ID              reduce using rule 48 (mulop -> MUL .)
    NUM             reduce using rule 48 (mulop -> MUL .)
    BVAL            reduce using rule 48 (mulop -> MUL .)
    SUB             reduce using rule 48 (mulop -> MUL .)


state 61

    (42) int_expr -> int_expr addop . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_term                       shift and go to state 84
    int_factor                     shift and go to state 40

state 62

    (37) compare_op -> EQUAL .

    LPAR            reduce using rule 37 (compare_op -> EQUAL .)
    ID              reduce using rule 37 (compare_op -> EQUAL .)
    NUM             reduce using rule 37 (compare_op -> EQUAL .)
    BVAL            reduce using rule 37 (compare_op -> EQUAL .)
    SUB             reduce using rule 37 (compare_op -> EQUAL .)


state 63

    (40) compare_op -> LE .

    LPAR            reduce using rule 40 (compare_op -> LE .)
    ID              reduce using rule 40 (compare_op -> LE .)
    NUM             reduce using rule 40 (compare_op -> LE .)
    BVAL            reduce using rule 40 (compare_op -> LE .)
    SUB             reduce using rule 40 (compare_op -> LE .)


state 64

    (41) compare_op -> GE .

    LPAR            reduce using rule 41 (compare_op -> GE .)
    ID              reduce using rule 41 (compare_op -> GE .)
    NUM             reduce using rule 41 (compare_op -> GE .)
    BVAL            reduce using rule 41 (compare_op -> GE .)
    SUB             reduce using rule 41 (compare_op -> GE .)


state 65

    (35) bint_factor -> int_expr compare_op . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_term                       shift and go to state 34
    int_expr                       shift and go to state 85
    int_factor                     shift and go to state 40

state 66

    (44) addop -> ADD .

    LPAR            reduce using rule 44 (addop -> ADD .)
    ID              reduce using rule 44 (addop -> ADD .)
    NUM             reduce using rule 44 (addop -> ADD .)
    BVAL            reduce using rule 44 (addop -> ADD .)
    SUB             reduce using rule 44 (addop -> ADD .)


state 67

    (38) compare_op -> LT .

    LPAR            reduce using rule 38 (compare_op -> LT .)
    ID              reduce using rule 38 (compare_op -> LT .)
    NUM             reduce using rule 38 (compare_op -> LT .)
    BVAL            reduce using rule 38 (compare_op -> LT .)
    SUB             reduce using rule 38 (compare_op -> LT .)


state 68

    (45) addop -> SUB .

    LPAR            reduce using rule 45 (addop -> SUB .)
    ID              reduce using rule 45 (addop -> SUB .)
    NUM             reduce using rule 45 (addop -> SUB .)
    BVAL            reduce using rule 45 (addop -> SUB .)
    SUB             reduce using rule 45 (addop -> SUB .)


state 69

    (39) compare_op -> GT .

    LPAR            reduce using rule 39 (compare_op -> GT .)
    ID              reduce using rule 39 (compare_op -> GT .)
    NUM             reduce using rule 39 (compare_op -> GT .)
    BVAL            reduce using rule 39 (compare_op -> GT .)
    SUB             reduce using rule 39 (compare_op -> GT .)


state 70

    (30) expr -> expr OR . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_term                       shift and go to state 34
    int_expr                       shift and go to state 36
    int_factor                     shift and go to state 40
    bint_factor                    shift and go to state 43
    bint_term                      shift and go to state 86

state 71

    (34) bint_factor -> NOT bint_factor .

    AND             reduce using rule 34 (bint_factor -> NOT bint_factor .)
    OR              reduce using rule 34 (bint_factor -> NOT bint_factor .)
    SEMICOLON       reduce using rule 34 (bint_factor -> NOT bint_factor .)
    ELSE            reduce using rule 34 (bint_factor -> NOT bint_factor .)
    DO              reduce using rule 34 (bint_factor -> NOT bint_factor .)
    THEN            reduce using rule 34 (bint_factor -> NOT bint_factor .)
    RPAR            reduce using rule 34 (bint_factor -> NOT bint_factor .)
    COMMA           reduce using rule 34 (bint_factor -> NOT bint_factor .)


state 72

    (55) argument_list -> LPAR . arguments RPAR
    (57) arguments -> . arguments1
    (58) arguments -> .
    (59) arguments1 -> . arguments1 COMMA expr
    (60) arguments1 -> . expr
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    RPAR            reduce using rule 58 (arguments -> .)
    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    arguments                      shift and go to state 87
    int_term                       shift and go to state 34
    int_expr                       shift and go to state 36
    expr                           shift and go to state 89
    int_factor                     shift and go to state 40
    arguments1                     shift and go to state 88
    bint_factor                    shift and go to state 43
    bint_term                      shift and go to state 45

state 73

    (51) int_factor -> ID argument_list .

    MUL             reduce using rule 51 (int_factor -> ID argument_list .)
    DIV             reduce using rule 51 (int_factor -> ID argument_list .)
    EQUAL           reduce using rule 51 (int_factor -> ID argument_list .)
    LT              reduce using rule 51 (int_factor -> ID argument_list .)
    GT              reduce using rule 51 (int_factor -> ID argument_list .)
    LE              reduce using rule 51 (int_factor -> ID argument_list .)
    GE              reduce using rule 51 (int_factor -> ID argument_list .)
    ADD             reduce using rule 51 (int_factor -> ID argument_list .)
    SUB             reduce using rule 51 (int_factor -> ID argument_list .)
    AND             reduce using rule 51 (int_factor -> ID argument_list .)
    OR              reduce using rule 51 (int_factor -> ID argument_list .)
    SEMICOLON       reduce using rule 51 (int_factor -> ID argument_list .)
    ELSE            reduce using rule 51 (int_factor -> ID argument_list .)
    DO              reduce using rule 51 (int_factor -> ID argument_list .)
    THEN            reduce using rule 51 (int_factor -> ID argument_list .)
    RPAR            reduce using rule 51 (int_factor -> ID argument_list .)
    COMMA           reduce using rule 51 (int_factor -> ID argument_list .)


state 74

    (50) int_factor -> LPAR expr . RPAR
    (30) expr -> expr . OR bint_term

    RPAR            shift and go to state 90
    OR              shift and go to state 70


state 75

    (54) int_factor -> SUB int_factor .

    MUL             reduce using rule 54 (int_factor -> SUB int_factor .)
    DIV             reduce using rule 54 (int_factor -> SUB int_factor .)
    EQUAL           reduce using rule 54 (int_factor -> SUB int_factor .)
    LT              reduce using rule 54 (int_factor -> SUB int_factor .)
    GT              reduce using rule 54 (int_factor -> SUB int_factor .)
    LE              reduce using rule 54 (int_factor -> SUB int_factor .)
    GE              reduce using rule 54 (int_factor -> SUB int_factor .)
    ADD             reduce using rule 54 (int_factor -> SUB int_factor .)
    SUB             reduce using rule 54 (int_factor -> SUB int_factor .)
    AND             reduce using rule 54 (int_factor -> SUB int_factor .)
    OR              reduce using rule 54 (int_factor -> SUB int_factor .)
    SEMICOLON       reduce using rule 54 (int_factor -> SUB int_factor .)
    ELSE            reduce using rule 54 (int_factor -> SUB int_factor .)
    DO              reduce using rule 54 (int_factor -> SUB int_factor .)
    THEN            reduce using rule 54 (int_factor -> SUB int_factor .)
    RPAR            reduce using rule 54 (int_factor -> SUB int_factor .)
    COMMA           reduce using rule 54 (int_factor -> SUB int_factor .)


state 76

    (32) bint_term -> bint_term AND . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_term                       shift and go to state 34
    int_expr                       shift and go to state 36
    int_factor                     shift and go to state 40
    bint_factor                    shift and go to state 91

state 77

    (25) prog_stmt -> WHILE expr DO . prog_stmt
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    IF              shift and go to state 25
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 24
    PRINT           shift and go to state 21
    CLPAR           shift and go to state 26

    prog_stmt                      shift and go to state 92

state 78

    (27) prog_stmt -> ID ASSIGN expr .
    (30) expr -> expr . OR bint_term

    SEMICOLON       reduce using rule 27 (prog_stmt -> ID ASSIGN expr .)
    ELSE            reduce using rule 27 (prog_stmt -> ID ASSIGN expr .)
    OR              shift and go to state 70


state 79

    (24) prog_stmt -> IF expr THEN . prog_stmt ELSE prog_stmt
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    IF              shift and go to state 25
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 24
    PRINT           shift and go to state 21
    CLPAR           shift and go to state 26

    prog_stmt                      shift and go to state 93

state 80

    (29) prog_stmt -> CLPAR block CRPAR .

    SEMICOLON       reduce using rule 29 (prog_stmt -> CLPAR block CRPAR .)
    ELSE            reduce using rule 29 (prog_stmt -> CLPAR block CRPAR .)


state 81

    (14) parameters1 -> parameters1 COMMA basic_var_declaration .

    COMMA           reduce using rule 14 (parameters1 -> parameters1 COMMA basic_var_declaration .)
    RPAR            reduce using rule 14 (parameters1 -> parameters1 COMMA basic_var_declaration .)


state 82

    (9) fun_declaration -> FUN identifier param_list COLON type CLPAR . fun_block CRPAR
    (10) fun_block -> . declarations fun_body
    (3) declarations -> . declaration SEMICOLON declarations
    (4) declarations -> .
    (5) declaration -> . var_declaration
    (6) declaration -> . fun_declaration
    (7) var_declaration -> . VAR basic_var_declaration
    (9) fun_declaration -> . FUN identifier param_list COLON type CLPAR fun_block CRPAR

    BEGIN           reduce using rule 4 (declarations -> .)
    IF              reduce using rule 4 (declarations -> .)
    WHILE           reduce using rule 4 (declarations -> .)
    READ            reduce using rule 4 (declarations -> .)
    ID              reduce using rule 4 (declarations -> .)
    PRINT           reduce using rule 4 (declarations -> .)
    CLPAR           reduce using rule 4 (declarations -> .)
    RETURN          reduce using rule 4 (declarations -> .)
    VAR             shift and go to state 8
    FUN             shift and go to state 2

    fun_block                      shift and go to state 94
    fun_declaration                shift and go to state 3
    declarations                   shift and go to state 95
    var_declaration                shift and go to state 7
    declaration                    shift and go to state 5

state 83

    (46) int_term -> int_term mulop int_factor .

    MUL             reduce using rule 46 (int_term -> int_term mulop int_factor .)
    DIV             reduce using rule 46 (int_term -> int_term mulop int_factor .)
    EQUAL           reduce using rule 46 (int_term -> int_term mulop int_factor .)
    LT              reduce using rule 46 (int_term -> int_term mulop int_factor .)
    GT              reduce using rule 46 (int_term -> int_term mulop int_factor .)
    LE              reduce using rule 46 (int_term -> int_term mulop int_factor .)
    GE              reduce using rule 46 (int_term -> int_term mulop int_factor .)
    ADD             reduce using rule 46 (int_term -> int_term mulop int_factor .)
    SUB             reduce using rule 46 (int_term -> int_term mulop int_factor .)
    AND             reduce using rule 46 (int_term -> int_term mulop int_factor .)
    OR              reduce using rule 46 (int_term -> int_term mulop int_factor .)
    COMMA           reduce using rule 46 (int_term -> int_term mulop int_factor .)
    RPAR            reduce using rule 46 (int_term -> int_term mulop int_factor .)
    DO              reduce using rule 46 (int_term -> int_term mulop int_factor .)
    SEMICOLON       reduce using rule 46 (int_term -> int_term mulop int_factor .)
    ELSE            reduce using rule 46 (int_term -> int_term mulop int_factor .)
    THEN            reduce using rule 46 (int_term -> int_term mulop int_factor .)


state 84

    (42) int_expr -> int_expr addop int_term .
    (46) int_term -> int_term . mulop int_factor
    (48) mulop -> . MUL
    (49) mulop -> . DIV

    EQUAL           reduce using rule 42 (int_expr -> int_expr addop int_term .)
    LT              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    GT              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    LE              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    GE              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    ADD             reduce using rule 42 (int_expr -> int_expr addop int_term .)
    SUB             reduce using rule 42 (int_expr -> int_expr addop int_term .)
    AND             reduce using rule 42 (int_expr -> int_expr addop int_term .)
    SEMICOLON       reduce using rule 42 (int_expr -> int_expr addop int_term .)
    OR              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    ELSE            reduce using rule 42 (int_expr -> int_expr addop int_term .)
    DO              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    THEN            reduce using rule 42 (int_expr -> int_expr addop int_term .)
    RPAR            reduce using rule 42 (int_expr -> int_expr addop int_term .)
    COMMA           reduce using rule 42 (int_expr -> int_expr addop int_term .)
    MUL             shift and go to state 60
    DIV             shift and go to state 59

    mulop                          shift and go to state 58

state 85

    (35) bint_factor -> int_expr compare_op int_expr .
    (42) int_expr -> int_expr . addop int_term
    (44) addop -> . ADD
    (45) addop -> . SUB

    AND             reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    OR              reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    SEMICOLON       reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    ELSE            reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    DO              reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    THEN            reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    RPAR            reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    COMMA           reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    ADD             shift and go to state 66
    SUB             shift and go to state 68

    addop                          shift and go to state 61

state 86

    (30) expr -> expr OR bint_term .
    (32) bint_term -> bint_term . AND bint_factor

    RPAR            reduce using rule 30 (expr -> expr OR bint_term .)
    OR              reduce using rule 30 (expr -> expr OR bint_term .)
    THEN            reduce using rule 30 (expr -> expr OR bint_term .)
    SEMICOLON       reduce using rule 30 (expr -> expr OR bint_term .)
    ELSE            reduce using rule 30 (expr -> expr OR bint_term .)
    COMMA           reduce using rule 30 (expr -> expr OR bint_term .)
    DO              reduce using rule 30 (expr -> expr OR bint_term .)
    AND             shift and go to state 76


state 87

    (55) argument_list -> LPAR arguments . RPAR

    RPAR            shift and go to state 96


state 88

    (57) arguments -> arguments1 .
    (59) arguments1 -> arguments1 . COMMA expr

    RPAR            reduce using rule 57 (arguments -> arguments1 .)
    COMMA           shift and go to state 97


state 89

    (60) arguments1 -> expr .
    (30) expr -> expr . OR bint_term

    COMMA           reduce using rule 60 (arguments1 -> expr .)
    RPAR            reduce using rule 60 (arguments1 -> expr .)
    OR              shift and go to state 70


state 90

    (50) int_factor -> LPAR expr RPAR .

    MUL             reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    DIV             reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    EQUAL           reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    LT              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    GT              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    LE              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    GE              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    ADD             reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    SUB             reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    AND             reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    OR              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    SEMICOLON       reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    ELSE            reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    DO              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    THEN            reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    RPAR            reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    COMMA           reduce using rule 50 (int_factor -> LPAR expr RPAR .)


state 91

    (32) bint_term -> bint_term AND bint_factor .

    AND             reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    OR              reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    SEMICOLON       reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    ELSE            reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    COMMA           reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    RPAR            reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    DO              reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    THEN            reduce using rule 32 (bint_term -> bint_term AND bint_factor .)


state 92

    (25) prog_stmt -> WHILE expr DO prog_stmt .

    SEMICOLON       reduce using rule 25 (prog_stmt -> WHILE expr DO prog_stmt .)
    ELSE            reduce using rule 25 (prog_stmt -> WHILE expr DO prog_stmt .)


state 93

    (24) prog_stmt -> IF expr THEN prog_stmt . ELSE prog_stmt

    ELSE            shift and go to state 98


state 94

    (9) fun_declaration -> FUN identifier param_list COLON type CLPAR fun_block . CRPAR

    CRPAR           shift and go to state 99


state 95

    (10) fun_block -> declarations . fun_body
    (20) fun_body -> . BEGIN prog_stmts RETURN expr SEMICOLON END
    (21) fun_body -> . prog_stmts RETURN expr SEMICOLON
    (22) prog_stmts -> . prog_stmt SEMICOLON prog_stmts
    (23) prog_stmts -> .
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    BEGIN           shift and go to state 100
    RETURN          reduce using rule 23 (prog_stmts -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 24
    PRINT           shift and go to state 21
    CLPAR           shift and go to state 26

    prog_stmt                      shift and go to state 19
    fun_body                       shift and go to state 101
    prog_stmts                     shift and go to state 102

state 96

    (55) argument_list -> LPAR arguments RPAR .

    MUL             reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    DIV             reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    EQUAL           reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    LT              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    GT              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    LE              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    GE              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    ADD             reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    SUB             reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    AND             reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    OR              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    SEMICOLON       reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    ELSE            reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    DO              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    THEN            reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    RPAR            reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    COMMA           reduce using rule 55 (argument_list -> LPAR arguments RPAR .)


state 97

    (59) arguments1 -> arguments1 COMMA . expr
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_term                       shift and go to state 34
    int_expr                       shift and go to state 36
    expr                           shift and go to state 103
    int_factor                     shift and go to state 40
    bint_factor                    shift and go to state 43
    bint_term                      shift and go to state 45

state 98

    (24) prog_stmt -> IF expr THEN prog_stmt ELSE . prog_stmt
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    IF              shift and go to state 25
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 24
    PRINT           shift and go to state 21
    CLPAR           shift and go to state 26

    prog_stmt                      shift and go to state 104

state 99

    (9) fun_declaration -> FUN identifier param_list COLON type CLPAR fun_block CRPAR .

    SEMICOLON       reduce using rule 9 (fun_declaration -> FUN identifier param_list COLON type CLPAR fun_block CRPAR .)


state 100

    (20) fun_body -> BEGIN . prog_stmts RETURN expr SEMICOLON END
    (22) prog_stmts -> . prog_stmt SEMICOLON prog_stmts
    (23) prog_stmts -> .
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    RETURN          reduce using rule 23 (prog_stmts -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 24
    PRINT           shift and go to state 21
    CLPAR           shift and go to state 26

    prog_stmt                      shift and go to state 19
    prog_stmts                     shift and go to state 105

state 101

    (10) fun_block -> declarations fun_body .

    CRPAR           reduce using rule 10 (fun_block -> declarations fun_body .)


state 102

    (21) fun_body -> prog_stmts . RETURN expr SEMICOLON

    RETURN          shift and go to state 106


state 103

    (59) arguments1 -> arguments1 COMMA expr .
    (30) expr -> expr . OR bint_term

    COMMA           reduce using rule 59 (arguments1 -> arguments1 COMMA expr .)
    RPAR            reduce using rule 59 (arguments1 -> arguments1 COMMA expr .)
    OR              shift and go to state 70


state 104

    (24) prog_stmt -> IF expr THEN prog_stmt ELSE prog_stmt .

    SEMICOLON       reduce using rule 24 (prog_stmt -> IF expr THEN prog_stmt ELSE prog_stmt .)
    ELSE            reduce using rule 24 (prog_stmt -> IF expr THEN prog_stmt ELSE prog_stmt .)


state 105

    (20) fun_body -> BEGIN prog_stmts . RETURN expr SEMICOLON END

    RETURN          shift and go to state 107


state 106

    (21) fun_body -> prog_stmts RETURN . expr SEMICOLON
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_term                       shift and go to state 34
    int_expr                       shift and go to state 36
    expr                           shift and go to state 108
    int_factor                     shift and go to state 40
    bint_factor                    shift and go to state 43
    bint_term                      shift and go to state 45

state 107

    (20) fun_body -> BEGIN prog_stmts RETURN . expr SEMICOLON END
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 38
    LPAR            shift and go to state 42
    ID              shift and go to state 41
    NUM             shift and go to state 39
    BVAL            shift and go to state 35
    SUB             shift and go to state 44

    int_term                       shift and go to state 34
    int_expr                       shift and go to state 36
    expr                           shift and go to state 109
    int_factor                     shift and go to state 40
    bint_factor                    shift and go to state 43
    bint_term                      shift and go to state 45

state 108

    (21) fun_body -> prog_stmts RETURN expr . SEMICOLON
    (30) expr -> expr . OR bint_term

    SEMICOLON       shift and go to state 110
    OR              shift and go to state 70


state 109

    (20) fun_body -> BEGIN prog_stmts RETURN expr . SEMICOLON END
    (30) expr -> expr . OR bint_term

    SEMICOLON       shift and go to state 111
    OR              shift and go to state 70


state 110

    (21) fun_body -> prog_stmts RETURN expr SEMICOLON .

    CRPAR           reduce using rule 21 (fun_body -> prog_stmts RETURN expr SEMICOLON .)


state 111

    (20) fun_body -> BEGIN prog_stmts RETURN expr SEMICOLON . END

    END             shift and go to state 112


state 112

    (20) fun_body -> BEGIN prog_stmts RETURN expr SEMICOLON END .

    CRPAR           reduce using rule 20 (fun_body -> BEGIN prog_stmts RETURN expr SEMICOLON END .)

