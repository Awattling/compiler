Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    COMMENTM

Grammar

Rule 0     S' -> prog
Rule 1     prog -> block
Rule 2     block -> declarations program_body
Rule 3     declarations -> declaration SEMICOLON declarations
Rule 4     declarations -> <empty>
Rule 5     declaration -> var_declaration
Rule 6     declaration -> fun_declaration
Rule 7     var_declaration -> VAR basic_var_declaration
Rule 8     basic_var_declaration -> identifier COLON type
Rule 9     fun_declaration -> FUN identifier param_list COLON type CLPAR fun_block CRPAR
Rule 10    fun_block -> declarations fun_body
Rule 11    param_list -> LPAR parameters RPAR
Rule 12    parameters -> parameters1
Rule 13    parameters -> <empty>
Rule 14    parameters1 -> parameters1 COMMA basic_var_declaration
Rule 15    parameters1 -> basic_var_declaration
Rule 16    identifier -> ID
Rule 17    type -> INT
Rule 18    type -> BOOL
Rule 19    program_body -> BEGIN prog_stmts END
Rule 20    fun_body -> BEGIN prog_stmts RETURN expr SEMICOLON END
Rule 21    fun_body -> prog_stmts RETURN expr SEMICOLON
Rule 22    prog_stmts -> prog_stmt SEMICOLON prog_stmts
Rule 23    prog_stmts -> <empty>
Rule 24    prog_stmt -> IF expr THEN prog_stmt ELSE prog_stmt
Rule 25    prog_stmt -> WHILE expr DO prog_stmt
Rule 26    prog_stmt -> READ ID
Rule 27    prog_stmt -> ID ASSIGN expr
Rule 28    prog_stmt -> PRINT expr
Rule 29    prog_stmt -> CLPAR block CRPAR
Rule 30    expr -> expr OR bint_term
Rule 31    expr -> bint_term
Rule 32    bint_term -> bint_term AND bint_factor
Rule 33    bint_term -> bint_factor
Rule 34    bint_factor -> NOT bint_factor
Rule 35    bint_factor -> int_expr compare_op int_expr
Rule 36    bint_factor -> int_expr
Rule 37    compare_op -> EQUAL
Rule 38    compare_op -> LT
Rule 39    compare_op -> GT
Rule 40    compare_op -> LE
Rule 41    compare_op -> GE
Rule 42    int_expr -> int_expr addop int_term
Rule 43    int_expr -> int_term
Rule 44    addop -> ADD
Rule 45    addop -> SUB
Rule 46    int_term -> int_term mulop int_factor
Rule 47    int_term -> int_factor
Rule 48    mulop -> MUL
Rule 49    mulop -> DIV
Rule 50    int_factor -> LPAR expr RPAR
Rule 51    int_factor -> ID argument_list
Rule 52    int_factor -> NUM
Rule 53    int_factor -> BVAL
Rule 54    int_factor -> SUB int_factor
Rule 55    argument_list -> LPAR arguments RPAR
Rule 56    argument_list -> <empty>
Rule 57    arguments -> arguments1
Rule 58    arguments -> <empty>
Rule 59    arguments1 -> arguments1 COMMA expr
Rule 60    arguments1 -> expr

Terminals, with rules where they appear

ADD                  : 44
AND                  : 32
ASSIGN               : 27
BEGIN                : 19 20
BOOL                 : 18
BVAL                 : 53
CLPAR                : 9 29
COLON                : 8 9
COMMA                : 14 59
COMMENT              : 
COMMENTM             : 
CRPAR                : 9 29
DIV                  : 49
DO                   : 25
ELSE                 : 24
END                  : 19 20
EQUAL                : 37
FUN                  : 9
GE                   : 41
GT                   : 39
ID                   : 16 26 27 51
IF                   : 24
INT                  : 17
LE                   : 40
LPAR                 : 11 50 55
LT                   : 38
MUL                  : 48
NOT                  : 34
NUM                  : 52
OR                   : 30
PRINT                : 28
READ                 : 26
RETURN               : 20 21
RPAR                 : 11 50 55
SEMICOLON            : 3 20 21 22
SUB                  : 45 54
THEN                 : 24
VAR                  : 7
WHILE                : 25
error                : 

Nonterminals, with rules where they appear

addop                : 42
argument_list        : 51
arguments            : 55
arguments1           : 57 59
basic_var_declaration : 7 14 15
bint_factor          : 32 33 34
bint_term            : 30 31 32
block                : 1 29
compare_op           : 35
declaration          : 3
declarations         : 2 3 10
expr                 : 20 21 24 25 27 28 30 50 59 60
fun_block            : 9
fun_body             : 10
fun_declaration      : 6
identifier           : 8 9
int_expr             : 35 35 36 42
int_factor           : 46 47 54
int_term             : 42 43 46
mulop                : 46
param_list           : 9
parameters           : 11
parameters1          : 12 14
prog                 : 0
prog_stmt            : 22 24 24 25
prog_stmts           : 19 20 21 22
program_body         : 2
type                 : 8 9
var_declaration      : 5

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . block
    (2) block -> . declarations program_body
    (3) declarations -> . declaration SEMICOLON declarations
    (4) declarations -> .
    (5) declaration -> . var_declaration
    (6) declaration -> . fun_declaration
    (7) var_declaration -> . VAR basic_var_declaration
    (9) fun_declaration -> . FUN identifier param_list COLON type CLPAR fun_block CRPAR

    BEGIN           reduce using rule 4 (declarations -> .)
    VAR             shift and go to state 8
    FUN             shift and go to state 6

    var_declaration                shift and go to state 1
    declarations                   shift and go to state 2
    block                          shift and go to state 3
    prog                           shift and go to state 4
    fun_declaration                shift and go to state 7
    declaration                    shift and go to state 5

state 1

    (5) declaration -> var_declaration .

    SEMICOLON       reduce using rule 5 (declaration -> var_declaration .)


state 2

    (2) block -> declarations . program_body
    (19) program_body -> . BEGIN prog_stmts END

    BEGIN           shift and go to state 10

    program_body                   shift and go to state 9

state 3

    (1) prog -> block .

    $end            reduce using rule 1 (prog -> block .)


state 4

    (0) S' -> prog .



state 5

    (3) declarations -> declaration . SEMICOLON declarations

    SEMICOLON       shift and go to state 11


state 6

    (9) fun_declaration -> FUN . identifier param_list COLON type CLPAR fun_block CRPAR
    (16) identifier -> . ID

    ID              shift and go to state 12

    identifier                     shift and go to state 13

state 7

    (6) declaration -> fun_declaration .

    SEMICOLON       reduce using rule 6 (declaration -> fun_declaration .)


state 8

    (7) var_declaration -> VAR . basic_var_declaration
    (8) basic_var_declaration -> . identifier COLON type
    (16) identifier -> . ID

    ID              shift and go to state 12

    basic_var_declaration          shift and go to state 14
    identifier                     shift and go to state 15

state 9

    (2) block -> declarations program_body .

    CRPAR           reduce using rule 2 (block -> declarations program_body .)
    $end            reduce using rule 2 (block -> declarations program_body .)


state 10

    (19) program_body -> BEGIN . prog_stmts END
    (22) prog_stmts -> . prog_stmt SEMICOLON prog_stmts
    (23) prog_stmts -> .
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    END             reduce using rule 23 (prog_stmts -> .)
    IF              shift and go to state 17
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 18
    PRINT           shift and go to state 20
    CLPAR           shift and go to state 19

    prog_stmt                      shift and go to state 16
    prog_stmts                     shift and go to state 21

state 11

    (3) declarations -> declaration SEMICOLON . declarations
    (3) declarations -> . declaration SEMICOLON declarations
    (4) declarations -> .
    (5) declaration -> . var_declaration
    (6) declaration -> . fun_declaration
    (7) var_declaration -> . VAR basic_var_declaration
    (9) fun_declaration -> . FUN identifier param_list COLON type CLPAR fun_block CRPAR

    BEGIN           reduce using rule 4 (declarations -> .)
    IF              reduce using rule 4 (declarations -> .)
    WHILE           reduce using rule 4 (declarations -> .)
    READ            reduce using rule 4 (declarations -> .)
    ID              reduce using rule 4 (declarations -> .)
    PRINT           reduce using rule 4 (declarations -> .)
    CLPAR           reduce using rule 4 (declarations -> .)
    RETURN          reduce using rule 4 (declarations -> .)
    VAR             shift and go to state 8
    FUN             shift and go to state 6

    fun_declaration                shift and go to state 7
    declarations                   shift and go to state 24
    var_declaration                shift and go to state 1
    declaration                    shift and go to state 5

state 12

    (16) identifier -> ID .

    LPAR            reduce using rule 16 (identifier -> ID .)
    COLON           reduce using rule 16 (identifier -> ID .)


state 13

    (9) fun_declaration -> FUN identifier . param_list COLON type CLPAR fun_block CRPAR
    (11) param_list -> . LPAR parameters RPAR

    LPAR            shift and go to state 26

    param_list                     shift and go to state 25

state 14

    (7) var_declaration -> VAR basic_var_declaration .

    SEMICOLON       reduce using rule 7 (var_declaration -> VAR basic_var_declaration .)


state 15

    (8) basic_var_declaration -> identifier . COLON type

    COLON           shift and go to state 27


state 16

    (22) prog_stmts -> prog_stmt . SEMICOLON prog_stmts

    SEMICOLON       shift and go to state 28


state 17

    (24) prog_stmt -> IF . expr THEN prog_stmt ELSE prog_stmt
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 30
    expr                           shift and go to state 33
    int_expr                       shift and go to state 32
    int_factor                     shift and go to state 34
    bint_term                      shift and go to state 39
    int_term                       shift and go to state 38

state 18

    (27) prog_stmt -> ID . ASSIGN expr

    ASSIGN          shift and go to state 41


state 19

    (29) prog_stmt -> CLPAR . block CRPAR
    (2) block -> . declarations program_body
    (3) declarations -> . declaration SEMICOLON declarations
    (4) declarations -> .
    (5) declaration -> . var_declaration
    (6) declaration -> . fun_declaration
    (7) var_declaration -> . VAR basic_var_declaration
    (9) fun_declaration -> . FUN identifier param_list COLON type CLPAR fun_block CRPAR

    BEGIN           reduce using rule 4 (declarations -> .)
    VAR             shift and go to state 8
    FUN             shift and go to state 6

    var_declaration                shift and go to state 1
    declarations                   shift and go to state 2
    block                          shift and go to state 42
    fun_declaration                shift and go to state 7
    declaration                    shift and go to state 5

state 20

    (28) prog_stmt -> PRINT . expr
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 30
    expr                           shift and go to state 43
    int_expr                       shift and go to state 32
    int_factor                     shift and go to state 34
    bint_term                      shift and go to state 39
    int_term                       shift and go to state 38

state 21

    (19) program_body -> BEGIN prog_stmts . END

    END             shift and go to state 44


state 22

    (25) prog_stmt -> WHILE . expr DO prog_stmt
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 30
    expr                           shift and go to state 45
    int_expr                       shift and go to state 32
    int_factor                     shift and go to state 34
    bint_term                      shift and go to state 39
    int_term                       shift and go to state 38

state 23

    (26) prog_stmt -> READ . ID

    ID              shift and go to state 46


state 24

    (3) declarations -> declaration SEMICOLON declarations .

    BEGIN           reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    IF              reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    WHILE           reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    READ            reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    ID              reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    PRINT           reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    CLPAR           reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)
    RETURN          reduce using rule 3 (declarations -> declaration SEMICOLON declarations .)


state 25

    (9) fun_declaration -> FUN identifier param_list . COLON type CLPAR fun_block CRPAR

    COLON           shift and go to state 47


state 26

    (11) param_list -> LPAR . parameters RPAR
    (12) parameters -> . parameters1
    (13) parameters -> .
    (14) parameters1 -> . parameters1 COMMA basic_var_declaration
    (15) parameters1 -> . basic_var_declaration
    (8) basic_var_declaration -> . identifier COLON type
    (16) identifier -> . ID

    RPAR            reduce using rule 13 (parameters -> .)
    ID              shift and go to state 12

    parameters1                    shift and go to state 48
    parameters                     shift and go to state 49
    basic_var_declaration          shift and go to state 50
    identifier                     shift and go to state 15

state 27

    (8) basic_var_declaration -> identifier COLON . type
    (17) type -> . INT
    (18) type -> . BOOL

    INT             shift and go to state 51
    BOOL            shift and go to state 52

    type                           shift and go to state 53

state 28

    (22) prog_stmts -> prog_stmt SEMICOLON . prog_stmts
    (22) prog_stmts -> . prog_stmt SEMICOLON prog_stmts
    (23) prog_stmts -> .
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    END             reduce using rule 23 (prog_stmts -> .)
    RETURN          reduce using rule 23 (prog_stmts -> .)
    IF              shift and go to state 17
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 18
    PRINT           shift and go to state 20
    CLPAR           shift and go to state 19

    prog_stmt                      shift and go to state 16
    prog_stmts                     shift and go to state 54

state 29

    (34) bint_factor -> NOT . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 55
    int_term                       shift and go to state 38
    int_expr                       shift and go to state 32
    int_factor                     shift and go to state 34

state 30

    (33) bint_term -> bint_factor .

    AND             reduce using rule 33 (bint_term -> bint_factor .)
    THEN            reduce using rule 33 (bint_term -> bint_factor .)
    OR              reduce using rule 33 (bint_term -> bint_factor .)
    SEMICOLON       reduce using rule 33 (bint_term -> bint_factor .)
    ELSE            reduce using rule 33 (bint_term -> bint_factor .)
    DO              reduce using rule 33 (bint_term -> bint_factor .)
    RPAR            reduce using rule 33 (bint_term -> bint_factor .)
    COMMA           reduce using rule 33 (bint_term -> bint_factor .)


state 31

    (53) int_factor -> BVAL .

    MUL             reduce using rule 53 (int_factor -> BVAL .)
    DIV             reduce using rule 53 (int_factor -> BVAL .)
    EQUAL           reduce using rule 53 (int_factor -> BVAL .)
    LT              reduce using rule 53 (int_factor -> BVAL .)
    GT              reduce using rule 53 (int_factor -> BVAL .)
    LE              reduce using rule 53 (int_factor -> BVAL .)
    GE              reduce using rule 53 (int_factor -> BVAL .)
    ADD             reduce using rule 53 (int_factor -> BVAL .)
    SUB             reduce using rule 53 (int_factor -> BVAL .)
    AND             reduce using rule 53 (int_factor -> BVAL .)
    OR              reduce using rule 53 (int_factor -> BVAL .)
    SEMICOLON       reduce using rule 53 (int_factor -> BVAL .)
    ELSE            reduce using rule 53 (int_factor -> BVAL .)
    THEN            reduce using rule 53 (int_factor -> BVAL .)
    DO              reduce using rule 53 (int_factor -> BVAL .)
    RPAR            reduce using rule 53 (int_factor -> BVAL .)
    COMMA           reduce using rule 53 (int_factor -> BVAL .)


state 32

    (35) bint_factor -> int_expr . compare_op int_expr
    (36) bint_factor -> int_expr .
    (42) int_expr -> int_expr . addop int_term
    (37) compare_op -> . EQUAL
    (38) compare_op -> . LT
    (39) compare_op -> . GT
    (40) compare_op -> . LE
    (41) compare_op -> . GE
    (44) addop -> . ADD
    (45) addop -> . SUB

    AND             reduce using rule 36 (bint_factor -> int_expr .)
    RPAR            reduce using rule 36 (bint_factor -> int_expr .)
    OR              reduce using rule 36 (bint_factor -> int_expr .)
    THEN            reduce using rule 36 (bint_factor -> int_expr .)
    SEMICOLON       reduce using rule 36 (bint_factor -> int_expr .)
    ELSE            reduce using rule 36 (bint_factor -> int_expr .)
    DO              reduce using rule 36 (bint_factor -> int_expr .)
    COMMA           reduce using rule 36 (bint_factor -> int_expr .)
    EQUAL           shift and go to state 61
    LT              shift and go to state 64
    GT              shift and go to state 58
    LE              shift and go to state 62
    GE              shift and go to state 60
    ADD             shift and go to state 63
    SUB             shift and go to state 59

    compare_op                     shift and go to state 56
    addop                          shift and go to state 57

state 33

    (24) prog_stmt -> IF expr . THEN prog_stmt ELSE prog_stmt
    (30) expr -> expr . OR bint_term

    THEN            shift and go to state 65
    OR              shift and go to state 66


state 34

    (47) int_term -> int_factor .

    MUL             reduce using rule 47 (int_term -> int_factor .)
    DIV             reduce using rule 47 (int_term -> int_factor .)
    EQUAL           reduce using rule 47 (int_term -> int_factor .)
    LT              reduce using rule 47 (int_term -> int_factor .)
    GT              reduce using rule 47 (int_term -> int_factor .)
    LE              reduce using rule 47 (int_term -> int_factor .)
    GE              reduce using rule 47 (int_term -> int_factor .)
    ADD             reduce using rule 47 (int_term -> int_factor .)
    SUB             reduce using rule 47 (int_term -> int_factor .)
    AND             reduce using rule 47 (int_term -> int_factor .)
    OR              reduce using rule 47 (int_term -> int_factor .)
    COMMA           reduce using rule 47 (int_term -> int_factor .)
    RPAR            reduce using rule 47 (int_term -> int_factor .)
    THEN            reduce using rule 47 (int_term -> int_factor .)
    SEMICOLON       reduce using rule 47 (int_term -> int_factor .)
    ELSE            reduce using rule 47 (int_term -> int_factor .)
    DO              reduce using rule 47 (int_term -> int_factor .)


state 35

    (50) int_factor -> LPAR . expr RPAR
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 30
    expr                           shift and go to state 67
    int_expr                       shift and go to state 32
    int_factor                     shift and go to state 34
    bint_term                      shift and go to state 39
    int_term                       shift and go to state 38

state 36

    (51) int_factor -> ID . argument_list
    (55) argument_list -> . LPAR arguments RPAR
    (56) argument_list -> .

    LPAR            shift and go to state 68
    MUL             reduce using rule 56 (argument_list -> .)
    DIV             reduce using rule 56 (argument_list -> .)
    EQUAL           reduce using rule 56 (argument_list -> .)
    LT              reduce using rule 56 (argument_list -> .)
    GT              reduce using rule 56 (argument_list -> .)
    LE              reduce using rule 56 (argument_list -> .)
    GE              reduce using rule 56 (argument_list -> .)
    ADD             reduce using rule 56 (argument_list -> .)
    SUB             reduce using rule 56 (argument_list -> .)
    AND             reduce using rule 56 (argument_list -> .)
    THEN            reduce using rule 56 (argument_list -> .)
    OR              reduce using rule 56 (argument_list -> .)
    SEMICOLON       reduce using rule 56 (argument_list -> .)
    ELSE            reduce using rule 56 (argument_list -> .)
    DO              reduce using rule 56 (argument_list -> .)
    RPAR            reduce using rule 56 (argument_list -> .)
    COMMA           reduce using rule 56 (argument_list -> .)

    argument_list                  shift and go to state 69

state 37

    (54) int_factor -> SUB . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    int_factor                     shift and go to state 70

state 38

    (43) int_expr -> int_term .
    (46) int_term -> int_term . mulop int_factor
    (48) mulop -> . MUL
    (49) mulop -> . DIV

    EQUAL           reduce using rule 43 (int_expr -> int_term .)
    LT              reduce using rule 43 (int_expr -> int_term .)
    GT              reduce using rule 43 (int_expr -> int_term .)
    LE              reduce using rule 43 (int_expr -> int_term .)
    GE              reduce using rule 43 (int_expr -> int_term .)
    ADD             reduce using rule 43 (int_expr -> int_term .)
    SUB             reduce using rule 43 (int_expr -> int_term .)
    AND             reduce using rule 43 (int_expr -> int_term .)
    THEN            reduce using rule 43 (int_expr -> int_term .)
    OR              reduce using rule 43 (int_expr -> int_term .)
    SEMICOLON       reduce using rule 43 (int_expr -> int_term .)
    ELSE            reduce using rule 43 (int_expr -> int_term .)
    DO              reduce using rule 43 (int_expr -> int_term .)
    RPAR            reduce using rule 43 (int_expr -> int_term .)
    COMMA           reduce using rule 43 (int_expr -> int_term .)
    MUL             shift and go to state 73
    DIV             shift and go to state 71

    mulop                          shift and go to state 72

state 39

    (31) expr -> bint_term .
    (32) bint_term -> bint_term . AND bint_factor

    OR              reduce using rule 31 (expr -> bint_term .)
    SEMICOLON       reduce using rule 31 (expr -> bint_term .)
    ELSE            reduce using rule 31 (expr -> bint_term .)
    DO              reduce using rule 31 (expr -> bint_term .)
    COMMA           reduce using rule 31 (expr -> bint_term .)
    RPAR            reduce using rule 31 (expr -> bint_term .)
    THEN            reduce using rule 31 (expr -> bint_term .)
    AND             shift and go to state 74


state 40

    (52) int_factor -> NUM .

    MUL             reduce using rule 52 (int_factor -> NUM .)
    DIV             reduce using rule 52 (int_factor -> NUM .)
    EQUAL           reduce using rule 52 (int_factor -> NUM .)
    LT              reduce using rule 52 (int_factor -> NUM .)
    GT              reduce using rule 52 (int_factor -> NUM .)
    LE              reduce using rule 52 (int_factor -> NUM .)
    GE              reduce using rule 52 (int_factor -> NUM .)
    ADD             reduce using rule 52 (int_factor -> NUM .)
    SUB             reduce using rule 52 (int_factor -> NUM .)
    AND             reduce using rule 52 (int_factor -> NUM .)
    OR              reduce using rule 52 (int_factor -> NUM .)
    SEMICOLON       reduce using rule 52 (int_factor -> NUM .)
    ELSE            reduce using rule 52 (int_factor -> NUM .)
    THEN            reduce using rule 52 (int_factor -> NUM .)
    DO              reduce using rule 52 (int_factor -> NUM .)
    RPAR            reduce using rule 52 (int_factor -> NUM .)
    COMMA           reduce using rule 52 (int_factor -> NUM .)


state 41

    (27) prog_stmt -> ID ASSIGN . expr
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 30
    expr                           shift and go to state 75
    int_expr                       shift and go to state 32
    int_factor                     shift and go to state 34
    bint_term                      shift and go to state 39
    int_term                       shift and go to state 38

state 42

    (29) prog_stmt -> CLPAR block . CRPAR

    CRPAR           shift and go to state 76


state 43

    (28) prog_stmt -> PRINT expr .
    (30) expr -> expr . OR bint_term

    SEMICOLON       reduce using rule 28 (prog_stmt -> PRINT expr .)
    ELSE            reduce using rule 28 (prog_stmt -> PRINT expr .)
    OR              shift and go to state 66


state 44

    (19) program_body -> BEGIN prog_stmts END .

    $end            reduce using rule 19 (program_body -> BEGIN prog_stmts END .)
    CRPAR           reduce using rule 19 (program_body -> BEGIN prog_stmts END .)


state 45

    (25) prog_stmt -> WHILE expr . DO prog_stmt
    (30) expr -> expr . OR bint_term

    DO              shift and go to state 77
    OR              shift and go to state 66


state 46

    (26) prog_stmt -> READ ID .

    SEMICOLON       reduce using rule 26 (prog_stmt -> READ ID .)
    ELSE            reduce using rule 26 (prog_stmt -> READ ID .)


state 47

    (9) fun_declaration -> FUN identifier param_list COLON . type CLPAR fun_block CRPAR
    (17) type -> . INT
    (18) type -> . BOOL

    INT             shift and go to state 51
    BOOL            shift and go to state 52

    type                           shift and go to state 78

state 48

    (12) parameters -> parameters1 .
    (14) parameters1 -> parameters1 . COMMA basic_var_declaration

    RPAR            reduce using rule 12 (parameters -> parameters1 .)
    COMMA           shift and go to state 79


state 49

    (11) param_list -> LPAR parameters . RPAR

    RPAR            shift and go to state 80


state 50

    (15) parameters1 -> basic_var_declaration .

    COMMA           reduce using rule 15 (parameters1 -> basic_var_declaration .)
    RPAR            reduce using rule 15 (parameters1 -> basic_var_declaration .)


state 51

    (17) type -> INT .

    SEMICOLON       reduce using rule 17 (type -> INT .)
    COMMA           reduce using rule 17 (type -> INT .)
    RPAR            reduce using rule 17 (type -> INT .)
    CLPAR           reduce using rule 17 (type -> INT .)


state 52

    (18) type -> BOOL .

    SEMICOLON       reduce using rule 18 (type -> BOOL .)
    COMMA           reduce using rule 18 (type -> BOOL .)
    RPAR            reduce using rule 18 (type -> BOOL .)
    CLPAR           reduce using rule 18 (type -> BOOL .)


state 53

    (8) basic_var_declaration -> identifier COLON type .

    COMMA           reduce using rule 8 (basic_var_declaration -> identifier COLON type .)
    RPAR            reduce using rule 8 (basic_var_declaration -> identifier COLON type .)
    SEMICOLON       reduce using rule 8 (basic_var_declaration -> identifier COLON type .)


state 54

    (22) prog_stmts -> prog_stmt SEMICOLON prog_stmts .

    RETURN          reduce using rule 22 (prog_stmts -> prog_stmt SEMICOLON prog_stmts .)
    END             reduce using rule 22 (prog_stmts -> prog_stmt SEMICOLON prog_stmts .)


state 55

    (34) bint_factor -> NOT bint_factor .

    AND             reduce using rule 34 (bint_factor -> NOT bint_factor .)
    RPAR            reduce using rule 34 (bint_factor -> NOT bint_factor .)
    OR              reduce using rule 34 (bint_factor -> NOT bint_factor .)
    THEN            reduce using rule 34 (bint_factor -> NOT bint_factor .)
    SEMICOLON       reduce using rule 34 (bint_factor -> NOT bint_factor .)
    ELSE            reduce using rule 34 (bint_factor -> NOT bint_factor .)
    DO              reduce using rule 34 (bint_factor -> NOT bint_factor .)
    COMMA           reduce using rule 34 (bint_factor -> NOT bint_factor .)


state 56

    (35) bint_factor -> int_expr compare_op . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    int_term                       shift and go to state 38
    int_expr                       shift and go to state 81
    int_factor                     shift and go to state 34

state 57

    (42) int_expr -> int_expr addop . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    int_term                       shift and go to state 82
    int_factor                     shift and go to state 34

state 58

    (39) compare_op -> GT .

    LPAR            reduce using rule 39 (compare_op -> GT .)
    ID              reduce using rule 39 (compare_op -> GT .)
    NUM             reduce using rule 39 (compare_op -> GT .)
    BVAL            reduce using rule 39 (compare_op -> GT .)
    SUB             reduce using rule 39 (compare_op -> GT .)


state 59

    (45) addop -> SUB .

    LPAR            reduce using rule 45 (addop -> SUB .)
    ID              reduce using rule 45 (addop -> SUB .)
    NUM             reduce using rule 45 (addop -> SUB .)
    BVAL            reduce using rule 45 (addop -> SUB .)
    SUB             reduce using rule 45 (addop -> SUB .)


state 60

    (41) compare_op -> GE .

    LPAR            reduce using rule 41 (compare_op -> GE .)
    ID              reduce using rule 41 (compare_op -> GE .)
    NUM             reduce using rule 41 (compare_op -> GE .)
    BVAL            reduce using rule 41 (compare_op -> GE .)
    SUB             reduce using rule 41 (compare_op -> GE .)


state 61

    (37) compare_op -> EQUAL .

    LPAR            reduce using rule 37 (compare_op -> EQUAL .)
    ID              reduce using rule 37 (compare_op -> EQUAL .)
    NUM             reduce using rule 37 (compare_op -> EQUAL .)
    BVAL            reduce using rule 37 (compare_op -> EQUAL .)
    SUB             reduce using rule 37 (compare_op -> EQUAL .)


state 62

    (40) compare_op -> LE .

    LPAR            reduce using rule 40 (compare_op -> LE .)
    ID              reduce using rule 40 (compare_op -> LE .)
    NUM             reduce using rule 40 (compare_op -> LE .)
    BVAL            reduce using rule 40 (compare_op -> LE .)
    SUB             reduce using rule 40 (compare_op -> LE .)


state 63

    (44) addop -> ADD .

    LPAR            reduce using rule 44 (addop -> ADD .)
    ID              reduce using rule 44 (addop -> ADD .)
    NUM             reduce using rule 44 (addop -> ADD .)
    BVAL            reduce using rule 44 (addop -> ADD .)
    SUB             reduce using rule 44 (addop -> ADD .)


state 64

    (38) compare_op -> LT .

    LPAR            reduce using rule 38 (compare_op -> LT .)
    ID              reduce using rule 38 (compare_op -> LT .)
    NUM             reduce using rule 38 (compare_op -> LT .)
    BVAL            reduce using rule 38 (compare_op -> LT .)
    SUB             reduce using rule 38 (compare_op -> LT .)


state 65

    (24) prog_stmt -> IF expr THEN . prog_stmt ELSE prog_stmt
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    IF              shift and go to state 17
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 18
    PRINT           shift and go to state 20
    CLPAR           shift and go to state 19

    prog_stmt                      shift and go to state 83

state 66

    (30) expr -> expr OR . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 30
    int_expr                       shift and go to state 32
    int_factor                     shift and go to state 34
    bint_term                      shift and go to state 84
    int_term                       shift and go to state 38

state 67

    (50) int_factor -> LPAR expr . RPAR
    (30) expr -> expr . OR bint_term

    RPAR            shift and go to state 85
    OR              shift and go to state 66


state 68

    (55) argument_list -> LPAR . arguments RPAR
    (57) arguments -> . arguments1
    (58) arguments -> .
    (59) arguments1 -> . arguments1 COMMA expr
    (60) arguments1 -> . expr
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    RPAR            reduce using rule 58 (arguments -> .)
    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 30
    int_expr                       shift and go to state 32
    arguments                      shift and go to state 86
    int_factor                     shift and go to state 34
    expr                           shift and go to state 87
    arguments1                     shift and go to state 88
    bint_term                      shift and go to state 39
    int_term                       shift and go to state 38

state 69

    (51) int_factor -> ID argument_list .

    MUL             reduce using rule 51 (int_factor -> ID argument_list .)
    DIV             reduce using rule 51 (int_factor -> ID argument_list .)
    EQUAL           reduce using rule 51 (int_factor -> ID argument_list .)
    LT              reduce using rule 51 (int_factor -> ID argument_list .)
    GT              reduce using rule 51 (int_factor -> ID argument_list .)
    LE              reduce using rule 51 (int_factor -> ID argument_list .)
    GE              reduce using rule 51 (int_factor -> ID argument_list .)
    ADD             reduce using rule 51 (int_factor -> ID argument_list .)
    SUB             reduce using rule 51 (int_factor -> ID argument_list .)
    AND             reduce using rule 51 (int_factor -> ID argument_list .)
    OR              reduce using rule 51 (int_factor -> ID argument_list .)
    SEMICOLON       reduce using rule 51 (int_factor -> ID argument_list .)
    ELSE            reduce using rule 51 (int_factor -> ID argument_list .)
    THEN            reduce using rule 51 (int_factor -> ID argument_list .)
    DO              reduce using rule 51 (int_factor -> ID argument_list .)
    RPAR            reduce using rule 51 (int_factor -> ID argument_list .)
    COMMA           reduce using rule 51 (int_factor -> ID argument_list .)


state 70

    (54) int_factor -> SUB int_factor .

    MUL             reduce using rule 54 (int_factor -> SUB int_factor .)
    DIV             reduce using rule 54 (int_factor -> SUB int_factor .)
    EQUAL           reduce using rule 54 (int_factor -> SUB int_factor .)
    LT              reduce using rule 54 (int_factor -> SUB int_factor .)
    GT              reduce using rule 54 (int_factor -> SUB int_factor .)
    LE              reduce using rule 54 (int_factor -> SUB int_factor .)
    GE              reduce using rule 54 (int_factor -> SUB int_factor .)
    ADD             reduce using rule 54 (int_factor -> SUB int_factor .)
    SUB             reduce using rule 54 (int_factor -> SUB int_factor .)
    AND             reduce using rule 54 (int_factor -> SUB int_factor .)
    OR              reduce using rule 54 (int_factor -> SUB int_factor .)
    SEMICOLON       reduce using rule 54 (int_factor -> SUB int_factor .)
    ELSE            reduce using rule 54 (int_factor -> SUB int_factor .)
    THEN            reduce using rule 54 (int_factor -> SUB int_factor .)
    DO              reduce using rule 54 (int_factor -> SUB int_factor .)
    RPAR            reduce using rule 54 (int_factor -> SUB int_factor .)
    COMMA           reduce using rule 54 (int_factor -> SUB int_factor .)


state 71

    (49) mulop -> DIV .

    LPAR            reduce using rule 49 (mulop -> DIV .)
    ID              reduce using rule 49 (mulop -> DIV .)
    NUM             reduce using rule 49 (mulop -> DIV .)
    BVAL            reduce using rule 49 (mulop -> DIV .)
    SUB             reduce using rule 49 (mulop -> DIV .)


state 72

    (46) int_term -> int_term mulop . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    int_factor                     shift and go to state 89

state 73

    (48) mulop -> MUL .

    LPAR            reduce using rule 48 (mulop -> MUL .)
    ID              reduce using rule 48 (mulop -> MUL .)
    NUM             reduce using rule 48 (mulop -> MUL .)
    BVAL            reduce using rule 48 (mulop -> MUL .)
    SUB             reduce using rule 48 (mulop -> MUL .)


state 74

    (32) bint_term -> bint_term AND . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 90
    int_term                       shift and go to state 38
    int_expr                       shift and go to state 32
    int_factor                     shift and go to state 34

state 75

    (27) prog_stmt -> ID ASSIGN expr .
    (30) expr -> expr . OR bint_term

    SEMICOLON       reduce using rule 27 (prog_stmt -> ID ASSIGN expr .)
    ELSE            reduce using rule 27 (prog_stmt -> ID ASSIGN expr .)
    OR              shift and go to state 66


state 76

    (29) prog_stmt -> CLPAR block CRPAR .

    SEMICOLON       reduce using rule 29 (prog_stmt -> CLPAR block CRPAR .)
    ELSE            reduce using rule 29 (prog_stmt -> CLPAR block CRPAR .)


state 77

    (25) prog_stmt -> WHILE expr DO . prog_stmt
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    IF              shift and go to state 17
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 18
    PRINT           shift and go to state 20
    CLPAR           shift and go to state 19

    prog_stmt                      shift and go to state 91

state 78

    (9) fun_declaration -> FUN identifier param_list COLON type . CLPAR fun_block CRPAR

    CLPAR           shift and go to state 92


state 79

    (14) parameters1 -> parameters1 COMMA . basic_var_declaration
    (8) basic_var_declaration -> . identifier COLON type
    (16) identifier -> . ID

    ID              shift and go to state 12

    basic_var_declaration          shift and go to state 93
    identifier                     shift and go to state 15

state 80

    (11) param_list -> LPAR parameters RPAR .

    COLON           reduce using rule 11 (param_list -> LPAR parameters RPAR .)


state 81

    (35) bint_factor -> int_expr compare_op int_expr .
    (42) int_expr -> int_expr . addop int_term
    (44) addop -> . ADD
    (45) addop -> . SUB

    AND             reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    RPAR            reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    OR              reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    THEN            reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    SEMICOLON       reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    ELSE            reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    DO              reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    COMMA           reduce using rule 35 (bint_factor -> int_expr compare_op int_expr .)
    ADD             shift and go to state 63
    SUB             shift and go to state 59

    addop                          shift and go to state 57

state 82

    (42) int_expr -> int_expr addop int_term .
    (46) int_term -> int_term . mulop int_factor
    (48) mulop -> . MUL
    (49) mulop -> . DIV

    EQUAL           reduce using rule 42 (int_expr -> int_expr addop int_term .)
    LT              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    GT              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    LE              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    GE              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    ADD             reduce using rule 42 (int_expr -> int_expr addop int_term .)
    SUB             reduce using rule 42 (int_expr -> int_expr addop int_term .)
    AND             reduce using rule 42 (int_expr -> int_expr addop int_term .)
    THEN            reduce using rule 42 (int_expr -> int_expr addop int_term .)
    OR              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    SEMICOLON       reduce using rule 42 (int_expr -> int_expr addop int_term .)
    ELSE            reduce using rule 42 (int_expr -> int_expr addop int_term .)
    DO              reduce using rule 42 (int_expr -> int_expr addop int_term .)
    RPAR            reduce using rule 42 (int_expr -> int_expr addop int_term .)
    COMMA           reduce using rule 42 (int_expr -> int_expr addop int_term .)
    MUL             shift and go to state 73
    DIV             shift and go to state 71

    mulop                          shift and go to state 72

state 83

    (24) prog_stmt -> IF expr THEN prog_stmt . ELSE prog_stmt

    ELSE            shift and go to state 94


state 84

    (30) expr -> expr OR bint_term .
    (32) bint_term -> bint_term . AND bint_factor

    OR              reduce using rule 30 (expr -> expr OR bint_term .)
    SEMICOLON       reduce using rule 30 (expr -> expr OR bint_term .)
    ELSE            reduce using rule 30 (expr -> expr OR bint_term .)
    DO              reduce using rule 30 (expr -> expr OR bint_term .)
    COMMA           reduce using rule 30 (expr -> expr OR bint_term .)
    RPAR            reduce using rule 30 (expr -> expr OR bint_term .)
    THEN            reduce using rule 30 (expr -> expr OR bint_term .)
    AND             shift and go to state 74


state 85

    (50) int_factor -> LPAR expr RPAR .

    MUL             reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    DIV             reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    EQUAL           reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    LT              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    GT              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    LE              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    GE              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    ADD             reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    SUB             reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    AND             reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    OR              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    SEMICOLON       reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    ELSE            reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    THEN            reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    DO              reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    RPAR            reduce using rule 50 (int_factor -> LPAR expr RPAR .)
    COMMA           reduce using rule 50 (int_factor -> LPAR expr RPAR .)


state 86

    (55) argument_list -> LPAR arguments . RPAR

    RPAR            shift and go to state 95


state 87

    (60) arguments1 -> expr .
    (30) expr -> expr . OR bint_term

    COMMA           reduce using rule 60 (arguments1 -> expr .)
    RPAR            reduce using rule 60 (arguments1 -> expr .)
    OR              shift and go to state 66


state 88

    (57) arguments -> arguments1 .
    (59) arguments1 -> arguments1 . COMMA expr

    RPAR            reduce using rule 57 (arguments -> arguments1 .)
    COMMA           shift and go to state 96


state 89

    (46) int_term -> int_term mulop int_factor .

    MUL             reduce using rule 46 (int_term -> int_term mulop int_factor .)
    DIV             reduce using rule 46 (int_term -> int_term mulop int_factor .)
    EQUAL           reduce using rule 46 (int_term -> int_term mulop int_factor .)
    LT              reduce using rule 46 (int_term -> int_term mulop int_factor .)
    GT              reduce using rule 46 (int_term -> int_term mulop int_factor .)
    LE              reduce using rule 46 (int_term -> int_term mulop int_factor .)
    GE              reduce using rule 46 (int_term -> int_term mulop int_factor .)
    ADD             reduce using rule 46 (int_term -> int_term mulop int_factor .)
    SUB             reduce using rule 46 (int_term -> int_term mulop int_factor .)
    AND             reduce using rule 46 (int_term -> int_term mulop int_factor .)
    OR              reduce using rule 46 (int_term -> int_term mulop int_factor .)
    COMMA           reduce using rule 46 (int_term -> int_term mulop int_factor .)
    RPAR            reduce using rule 46 (int_term -> int_term mulop int_factor .)
    THEN            reduce using rule 46 (int_term -> int_term mulop int_factor .)
    SEMICOLON       reduce using rule 46 (int_term -> int_term mulop int_factor .)
    ELSE            reduce using rule 46 (int_term -> int_term mulop int_factor .)
    DO              reduce using rule 46 (int_term -> int_term mulop int_factor .)


state 90

    (32) bint_term -> bint_term AND bint_factor .

    AND             reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    THEN            reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    OR              reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    SEMICOLON       reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    ELSE            reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    DO              reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    RPAR            reduce using rule 32 (bint_term -> bint_term AND bint_factor .)
    COMMA           reduce using rule 32 (bint_term -> bint_term AND bint_factor .)


state 91

    (25) prog_stmt -> WHILE expr DO prog_stmt .

    SEMICOLON       reduce using rule 25 (prog_stmt -> WHILE expr DO prog_stmt .)
    ELSE            reduce using rule 25 (prog_stmt -> WHILE expr DO prog_stmt .)


state 92

    (9) fun_declaration -> FUN identifier param_list COLON type CLPAR . fun_block CRPAR
    (10) fun_block -> . declarations fun_body
    (3) declarations -> . declaration SEMICOLON declarations
    (4) declarations -> .
    (5) declaration -> . var_declaration
    (6) declaration -> . fun_declaration
    (7) var_declaration -> . VAR basic_var_declaration
    (9) fun_declaration -> . FUN identifier param_list COLON type CLPAR fun_block CRPAR

    BEGIN           reduce using rule 4 (declarations -> .)
    IF              reduce using rule 4 (declarations -> .)
    WHILE           reduce using rule 4 (declarations -> .)
    READ            reduce using rule 4 (declarations -> .)
    ID              reduce using rule 4 (declarations -> .)
    PRINT           reduce using rule 4 (declarations -> .)
    CLPAR           reduce using rule 4 (declarations -> .)
    RETURN          reduce using rule 4 (declarations -> .)
    VAR             shift and go to state 8
    FUN             shift and go to state 6

    var_declaration                shift and go to state 1
    declarations                   shift and go to state 97
    fun_block                      shift and go to state 98
    declaration                    shift and go to state 5
    fun_declaration                shift and go to state 7

state 93

    (14) parameters1 -> parameters1 COMMA basic_var_declaration .

    COMMA           reduce using rule 14 (parameters1 -> parameters1 COMMA basic_var_declaration .)
    RPAR            reduce using rule 14 (parameters1 -> parameters1 COMMA basic_var_declaration .)


state 94

    (24) prog_stmt -> IF expr THEN prog_stmt ELSE . prog_stmt
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    IF              shift and go to state 17
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 18
    PRINT           shift and go to state 20
    CLPAR           shift and go to state 19

    prog_stmt                      shift and go to state 99

state 95

    (55) argument_list -> LPAR arguments RPAR .

    MUL             reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    DIV             reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    EQUAL           reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    LT              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    GT              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    LE              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    GE              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    ADD             reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    SUB             reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    AND             reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    THEN            reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    OR              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    SEMICOLON       reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    ELSE            reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    DO              reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    RPAR            reduce using rule 55 (argument_list -> LPAR arguments RPAR .)
    COMMA           reduce using rule 55 (argument_list -> LPAR arguments RPAR .)


state 96

    (59) arguments1 -> arguments1 COMMA . expr
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 30
    expr                           shift and go to state 100
    int_expr                       shift and go to state 32
    int_term                       shift and go to state 38
    int_factor                     shift and go to state 34
    bint_term                      shift and go to state 39

state 97

    (10) fun_block -> declarations . fun_body
    (20) fun_body -> . BEGIN prog_stmts RETURN expr SEMICOLON END
    (21) fun_body -> . prog_stmts RETURN expr SEMICOLON
    (22) prog_stmts -> . prog_stmt SEMICOLON prog_stmts
    (23) prog_stmts -> .
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    BEGIN           shift and go to state 103
    RETURN          reduce using rule 23 (prog_stmts -> .)
    IF              shift and go to state 17
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 18
    PRINT           shift and go to state 20
    CLPAR           shift and go to state 19

    prog_stmts                     shift and go to state 102
    prog_stmt                      shift and go to state 16
    fun_body                       shift and go to state 101

state 98

    (9) fun_declaration -> FUN identifier param_list COLON type CLPAR fun_block . CRPAR

    CRPAR           shift and go to state 104


state 99

    (24) prog_stmt -> IF expr THEN prog_stmt ELSE prog_stmt .

    SEMICOLON       reduce using rule 24 (prog_stmt -> IF expr THEN prog_stmt ELSE prog_stmt .)
    ELSE            reduce using rule 24 (prog_stmt -> IF expr THEN prog_stmt ELSE prog_stmt .)


state 100

    (59) arguments1 -> arguments1 COMMA expr .
    (30) expr -> expr . OR bint_term

    COMMA           reduce using rule 59 (arguments1 -> arguments1 COMMA expr .)
    RPAR            reduce using rule 59 (arguments1 -> arguments1 COMMA expr .)
    OR              shift and go to state 66


state 101

    (10) fun_block -> declarations fun_body .

    CRPAR           reduce using rule 10 (fun_block -> declarations fun_body .)


state 102

    (21) fun_body -> prog_stmts . RETURN expr SEMICOLON

    RETURN          shift and go to state 105


state 103

    (20) fun_body -> BEGIN . prog_stmts RETURN expr SEMICOLON END
    (22) prog_stmts -> . prog_stmt SEMICOLON prog_stmts
    (23) prog_stmts -> .
    (24) prog_stmt -> . IF expr THEN prog_stmt ELSE prog_stmt
    (25) prog_stmt -> . WHILE expr DO prog_stmt
    (26) prog_stmt -> . READ ID
    (27) prog_stmt -> . ID ASSIGN expr
    (28) prog_stmt -> . PRINT expr
    (29) prog_stmt -> . CLPAR block CRPAR

    RETURN          reduce using rule 23 (prog_stmts -> .)
    IF              shift and go to state 17
    WHILE           shift and go to state 22
    READ            shift and go to state 23
    ID              shift and go to state 18
    PRINT           shift and go to state 20
    CLPAR           shift and go to state 19

    prog_stmt                      shift and go to state 16
    prog_stmts                     shift and go to state 106

state 104

    (9) fun_declaration -> FUN identifier param_list COLON type CLPAR fun_block CRPAR .

    SEMICOLON       reduce using rule 9 (fun_declaration -> FUN identifier param_list COLON type CLPAR fun_block CRPAR .)


state 105

    (21) fun_body -> prog_stmts RETURN . expr SEMICOLON
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 30
    expr                           shift and go to state 107
    int_expr                       shift and go to state 32
    int_factor                     shift and go to state 34
    bint_term                      shift and go to state 39
    int_term                       shift and go to state 38

state 106

    (20) fun_body -> BEGIN prog_stmts . RETURN expr SEMICOLON END

    RETURN          shift and go to state 108


state 107

    (21) fun_body -> prog_stmts RETURN expr . SEMICOLON
    (30) expr -> expr . OR bint_term

    SEMICOLON       shift and go to state 109
    OR              shift and go to state 66


state 108

    (20) fun_body -> BEGIN prog_stmts RETURN . expr SEMICOLON END
    (30) expr -> . expr OR bint_term
    (31) expr -> . bint_term
    (32) bint_term -> . bint_term AND bint_factor
    (33) bint_term -> . bint_factor
    (34) bint_factor -> . NOT bint_factor
    (35) bint_factor -> . int_expr compare_op int_expr
    (36) bint_factor -> . int_expr
    (42) int_expr -> . int_expr addop int_term
    (43) int_expr -> . int_term
    (46) int_term -> . int_term mulop int_factor
    (47) int_term -> . int_factor
    (50) int_factor -> . LPAR expr RPAR
    (51) int_factor -> . ID argument_list
    (52) int_factor -> . NUM
    (53) int_factor -> . BVAL
    (54) int_factor -> . SUB int_factor

    NOT             shift and go to state 29
    LPAR            shift and go to state 35
    ID              shift and go to state 36
    NUM             shift and go to state 40
    BVAL            shift and go to state 31
    SUB             shift and go to state 37

    bint_factor                    shift and go to state 30
    expr                           shift and go to state 110
    int_expr                       shift and go to state 32
    int_factor                     shift and go to state 34
    bint_term                      shift and go to state 39
    int_term                       shift and go to state 38

state 109

    (21) fun_body -> prog_stmts RETURN expr SEMICOLON .

    CRPAR           reduce using rule 21 (fun_body -> prog_stmts RETURN expr SEMICOLON .)


state 110

    (20) fun_body -> BEGIN prog_stmts RETURN expr . SEMICOLON END
    (30) expr -> expr . OR bint_term

    SEMICOLON       shift and go to state 111
    OR              shift and go to state 66


state 111

    (20) fun_body -> BEGIN prog_stmts RETURN expr SEMICOLON . END

    END             shift and go to state 112


state 112

    (20) fun_body -> BEGIN prog_stmts RETURN expr SEMICOLON END .

    CRPAR           reduce using rule 20 (fun_body -> BEGIN prog_stmts RETURN expr SEMICOLON END .)

